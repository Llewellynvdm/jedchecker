<?php
/**
 * @package    Joomla.JEDChecker
 *
 * @copyright  Copyright (C) 2025 Open Source Matters, Inc. All rights reserved.
 *
 * @license    GNU General Public License version 2 or later; see LICENSE.txt
 */

defined('_JEXEC') or die('Restricted access');

use Joomla\Filesystem\Folder;
use Joomla\CMS\Language\Text;

// Include the rule base class
require_once JPATH_COMPONENT_ADMINISTRATOR . '/models/rule.php';

// Include the helper class
require_once JPATH_COMPONENT_ADMINISTRATOR . '/libraries/helper.php';

/**
 * JedcheckerRulesPhp
 *
 * @since  1.0
 * Checks for PHP compatibility issues - deprecated/removed functions
 */
class JedcheckerRulesPhp extends JEDcheckerRule
{
	/**
	 * The formal ID of this rule.
	 *
	 * @var    string
	 */
	protected $id = 'PHP';

	/**
	 * The title or caption of this rule.
	 *
	 * @var    string
	 */
	protected $title = 'COM_JEDCHECKER_RULE_PHP';

	/**
	 * The description of this rule.
	 *
	 * @var    string
	 */
	protected $description = 'COM_JEDCHECKER_RULE_PHP_DESC';

	/**
	 * The ordering value to sort rules in the menu.
	 *
	 * @var    integer
	 */
	public static $ordering = 725;

	protected $tests = false;

	/**
	 * Initiates the file search and check
	 *
	 * @return    void
	 */
	public function check()
	{
		$files = Folder::files($this->basedir, '\.php$', true, true);

		foreach ($files as $file)
		{
			// Process the file
			$this->find($file);
		}
	}

	/**
	 * reads a file and searches for any function defined in the params
	 *
	 * @param   string  $file  The file name
	 *
	 * @return    boolean            True if the statement was found, otherwise False.
	 */
	protected function find($file)
	{
		$origContent = (array) file($file);

		if (count($origContent) === 0)
		{
			return false;
		}

		$result = false;

		$content = file_get_contents($file);

		// Clean non-code
		$cleanContent = JEDCheckerHelper::cleanPhpCode(
			$content,
			JEDCheckerHelper::CLEAN_HTML | JEDCheckerHelper::CLEAN_COMMENTS | JEDCheckerHelper::CLEAN_STRINGS
		);

		$cleanContent = JEDCheckerHelper::splitLines($cleanContent);

		// Run tests
		foreach ($this->getTests() as $testObject)
		{
			if ($this->runTest($file, $origContent, $cleanContent, $testObject))
			{
				$result = true;
			}
		}

		return $result;
	}

	/**
	 * runs tests and reports to the appropriate function if strings match.
	 *
	 * @param   string  $file         The file name
	 * @param   array   $origContent  The file content
	 * @param   array   $cleanContent The file content w/o non-code elements
	 * @param   object  $testObject   The test object generated by getTests()
	 *
	 * @return boolean
	 */
	private function runTest($file, $origContent, $cleanContent, $testObject)
	{
		$error_count = 0;

		foreach ($cleanContent as $line_number => $line)
		{
			$origLine = $origContent[$line_number];

			foreach ($testObject->tests as $singleTest)
			{
				if (preg_match($singleTest->regex, $line))
				{
					// Highlight the matched pattern, then escape for HTML display
					$highlightedLine = str_ireplace($singleTest->test, '<b>' . $singleTest->test . '</b>', $origLine);
					$highlightedLine = htmlspecialchars($highlightedLine, ENT_NOQUOTES);
					// Restore the <b> tags
					$highlightedLine = str_replace(['&lt;b&gt;', '&lt;/b&gt;'], ['<b>', '</b>'], $highlightedLine);

                    $langKey = (strpos($testObject->group, 'deprecated') === 0) ? 'COM_JEDCHECKER_ERROR_PHP_DEPRECATED' : 'COM_JEDCHECKER_ERROR_PHP_REMOVED';
                    $error_message = sprintf(Text::_($langKey), $testObject->version) . ':<pre>' . $highlightedLine . '</pre>';

					if ($singleTest->replacement !== false)
					{
						$error_message .= Text::_('COM_JEDCHECKER_ERROR_PHP_INSTEAD_USE') . ': ' . $singleTest->replacement;
					}

					switch ($testObject->kind)
					{
						case 'error':
							$this->report->addError($file, $error_message, $line_number);
							break;
						default:
							// Case 'warning':
							$this->report->addWarning($file, $error_message, $line_number);
							break;
					}

					$error_count++;
				}

				// If you scored 100 errors on a single file, that's enough for now.
				if ($error_count > 100)
				{
					return true;
				}
			}
		}

		return $error_count > 0;
	}

	/**
	 * Lazyloads the tests from the php_deprecated.json file.
	 *
	 * @return array
	 */
	private function getTests()
	{
		if (!$this->tests)
		{
			// Build the test array
			$this->tests = array();

			// Load deprecation patterns from JSON file
			$this->loadDeprecatedPatterns();
		}

		return $this->tests;
	}

	/**
	 * Load deprecation patterns from php_deprecated.json
	 *
	 * @return void
	 */
	private function loadDeprecatedPatterns()
	{
		$deprecatedFile = __DIR__ . '/php_deprecated.json';

		if (!file_exists($deprecatedFile))
		{
			return;
		}

		$jsonContent = file_get_contents($deprecatedFile);

		if ($jsonContent === false)
		{
			return;
		}

		$sections = json_decode($jsonContent, true);

		if (!is_array($sections))
		{
			return;
		}

		foreach ($sections as $sectionName => $patterns)
		{
			$newTest = new stdClass;
			$newTest->group = $sectionName;

			// Determine the kind of error based on section name
			// Sections starting with "removed" are errors, others are warnings
			$newTest->kind = (strpos($sectionName, 'removed') === 0) ? 'error' : 'warning';
			$newTest->tests = array();

			// Parse section name to extract version (e.g., "deprecated-in-php-7.4" => "7.4")
			if (preg_match('/(?:deprecated|removed)-in-php-(.+)/', $sectionName, $matches))
			{
				$newTest->version = $matches[1];
			}
			else
			{
				$newTest->version = null;
			}

			foreach ($patterns as $pattern => $replacement)
			{
				$testObj = new stdClass;
				$testObj->test = $pattern;
				$testObj->regex = $this->generateRegex($pattern);
				$testObj->replacement = ($replacement !== '') ? $replacement : false;

				$newTest->tests[] = $testObj;
			}

			$this->tests[] = $newTest;
		}
	}

	/**
	 * Generates regular expression for a given test
	 *
	 * @param   string  $test  The string to match
	 *
	 * @return string
	 */
	private function generateRegex($test)
	{
		$regex = preg_quote($test, '/');

		// Add word boundary check for rules staring/ending with a letter (to avoid false-positives because of partial match)
		if (ctype_alpha($test[0]))
		{
			$regex = '\b' . $regex;
		}

		if (ctype_alpha($test[strlen($test) - 1]))
		{
			$regex .= '\b';
		}

		return '/' . $regex . '/i';
	}
}
